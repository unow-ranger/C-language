指针

## 1. 指向函数的指针

如果在程序中定义了一个函数，在编译时，编译系统为函数代码分配一段存储空间，这段存储空间的起始位置成为这个函数的指针。

如果想调用一个函数，除了可以通过函数名调用以外，还可以通过指向函数的指针变量来调用该函数。

例如：

```c
# include<stdio.h>
int main()
{
    int max(int, int);
    int (*p)(int, int);
    int a=10,b=20,c;
    p = max;
    c = (*p)(a,b);
    printf("%d",c);
    return 0;
}
int max(int x, int y)
{
    int z;
    if( x > y )
        z = x;
    else
        z = y;
    return z;
}
```

在上面程序中，**int(*p)(int,int);** 定义 p 是一个指向函数的变量指针，最前面的 int 表示这个函数返回的值是整型的。最后面的括号中有两个 int ，表示这个函数有 2 个 int 型参数。

**注意：** *p 两侧的括号不可省略，表示 p 先与 * 结合，是指针变量，然后再与后面的 () 结合，() 表示函数。如果写成了 “**int * p(int,int)**” ，由于 () 优先级高于 * ，它相当于 “**int * (p(int,int))**”，就成了声明一个 p 函数了，同时这个 p 函数的返回值是指向整型变量的指针，即返回值为一个整型指针变量。

### 1.1. 用指向函数的指针作函数的参数

从例子中分析

```c
#include<stdio.h>
int f1(int i)
{
	return ++i; 
}
int f2(int i, int j)
{
    return i+j;
}

int fun(int (*p1)(int), int (*p2)(int,int)) 
{
    int a,b,i=3,j=5;
    a = (*p1)(i);
    b = (*p2)(i,j);
    return a+b;
}

int main()
{
    int (*p1)(int);
    p1 = f1;
    int (*p2)(int,int);
    p2 = f2;
    printf("%d\n", fun(p1,p2));
    return 0;
}
```



## 2. 动态内存分配与指向他的指针变量

### 2.1. 什么是内存的动态分配

全局变量是分配在**内存中的静态存储区**的，而静态的局部变量（包括形参）是分配在**内存中的动态存储区**的，这个存储区是一个称为 **栈(stack)** 的区域。

然后，C 语言还允许内存动态分配区域，自由存储，称为**堆(heap)**区。可以根据需要，向系统申请所需大小的空间。由于该操作是自由的，对内存可以随时开辟随机释放，所以通常没在有声明部分定义它们为变量或数组，因此只能通过指针来引用。

### 2.2. 怎么建立内存的动态分配

对内存的动态分配，主要通过系统提供的库函数来实现的，主要有 malloc，calloc，free，realloc 这 4 个函数，这 4 个函数的声明在 **stdlib.h** 头文件中。

### 2.3. malloc

```c
void * malloc(unsigned int size);
```

其作用是在内存的动态存储区中分配一个长度为 size 的连续空间。

此函数是一个指针型函数，返回的指针指向该分配域的开头位置。

注意：该指针的基类为 void ，即不指向任何类型的数据，只提供一个地址。如果此函数为能成功执行（如内存不足），则返回空指针（NULL）。



### 2.4. calloc

```c
void * calloc( unsigned n, unsigned size );
```

其作用是在内存的动态存储区中分配 n 哥长度为 size 的连续空间，这个空间一般比较大，足以保存一个数组。

用 calloc 可以为一维数组开盘动态存储空间，n 为数组元素个数，每个元素长度为 size，这就是动态数组。

函数返回指向所分配域的起始位置的指针；如果分配不成功，返回 NULL。



### 2.5. free

```c
void free(void * p);
```

其作用是释放指针变量 p 所指向的动态空间，使这部分空间能重新被其他变量使用。free 无返回值。



### 2.6. realloc

```c
void * realloc(void * p, unsigned int size);
```

如果已经通过 malloc 函数或 calloc 函数获得了动态空间，想改变其大小，可以用 recalloc 函数重新分配。

用 realloc 函数将 p 所指向的动态空间的大小改变为 size。p 的值不变。如果重新分配不成功，返回 NULL。



## 3. void 指针类型

C99 允许使用基类型为 void 的指针类型。可以定一个基类型为 void 的指针变量，他不指向任何类型的数据。可以理解为 “不指向确定的类型” 的数据。在将他的值赋给另一指针变量时由系统对它进行类型转换，使之适合于被赋值的变量的类型。例如：

```c
int a = 3;
int *p1 = &a; 			//p1 指向 int 型变量
char *p2; 				//p2 指向 char 型变量
void *p3; 				//p3 为无类型指针变量(基类型为 void 型)
p3 = (void *)p1; 		//将 p1 的值转换为 void* 类型，然后赋值给 p3
p2 = (char *)p3; 		//将 p3 的值转换为 char* 类型，然后赋值给 p2
printf("%d\n",*p1); 	//合法，输出 a 的值
p3 = &a;
printf("%d\n",*p3); 	//错误，p3 是无指向的，不能指向 a
```

> 当把 void 指针赋值给不同基类型的指针变量(或相反)时，编译系统会自动进行转换，不必用户自己进行强制转换。

## 4. 指针变量的类型及含义

| 变量定义       | 类型表示    | 含义                                                         |
| -------------- | ----------- | ------------------------------------------------------------ |
| int i;         | int         | 定义整型变量                                                 |
| int * p;       | int *       | 定义 p 为指向整型数据的指针变量                              |
| int a[5];      | int [5]     | 定义整型数组 a，它有 5 个元素                                |
| int * p[4];    | int  * [4]  | 定义指针数组 p，它由 4 个指向整型数据的指针元素组成          |
| int ( * p)[4]; | int (*) [4] | p 为指向包含 4 个元素的一维数组的指针变量                    |
| int f();       | int ()      | f 为返回整型函数值的函数                                     |
| int * p();     | int * ()    | p 为返回一个指针的函数，该指针指向整型数据                   |
| Int ( * p)();  | int (*)()   | p 为指向函数的指针，该函数返回一个整型值                     |
| int **p;       | int **      | p 是一个指针变量，他指向一个指向整型数据的指针变量           |
| void * p;      | void *      | p 是一个指针变量，基类型为 void （空类型），不指向具体的对象 |

